package main

import (
	"context"
	"database/sql"
	"fmt"
	"log"
	"math/rand"
	"os"
	"strconv"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
	_ "github.com/lib/pq" // PostgreSQL driver
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"github.com/gocql/gocql" // Cassandra driver
)

// Configuration for each database
type Config struct {
	Enabled bool
	Host    string
	Port    string
	User    string
	Password string
	Database string
}

// Customer represents a customer record
type Customer struct {
	ID        int64
	FirstName string
	LastName  string
	Email     string
	CreatedAt time.Time
}

// Order represents an order record
type Order struct {
	ID         int64
	CustomerID int64
	OrderDate  time.Time
	Status     string
	Total      float64
}

func main() {
	// Initialize configurations
	mysqlConfig := getDBConfig("MYSQL")
	postgresConfig := getDBConfig("POSTGRESQL")
	mongoConfig := getDBConfig("MONGODB")
	oracleConfig := getDBConfig("ORACLE")
	cassandraConfig := getDBConfig("CASSANDRA")

	log.Println("Data generator starting...")
	log.Printf("MySQL enabled: %v", mysqlConfig.Enabled)
	log.Printf("PostgreSQL enabled: %v", postgresConfig.Enabled)
	log.Printf("MongoDB enabled: %v", mongoConfig.Enabled)
	log.Printf("Oracle enabled: %v", oracleConfig.Enabled)
	log.Printf("Cassandra enabled: %v", cassandraConfig.Enabled)

	// Seed the random number generator
	rand.Seed(time.Now().UnixNano())

	// Process enabled databases
	if mysqlConfig.Enabled {
		if err := generateMySQLData(mysqlConfig); err != nil {
			log.Printf("Error generating MySQL data: %v", err)
		}
	}

	if postgresConfig.Enabled {
		if err := generatePostgreSQLData(postgresConfig); err != nil {
			log.Printf("Error generating PostgreSQL data: %v", err)
		}
	}

	if mongoConfig.Enabled {
		if err := generateMongoDBData(mongoConfig); err != nil {
			log.Printf("Error generating MongoDB data: %v", err)
		}
	}

	if oracleConfig.Enabled {
		if err := generateOracleData(oracleConfig); err != nil {
			log.Printf("Error generating Oracle data: %v", err)
		}
	}

	if cassandraConfig.Enabled {
		if err := generateCassandraData(cassandraConfig); err != nil {
			log.Printf("Error generating Cassandra data: %v", err)
		}
	}

	log.Println("Data generation completed successfully")
}

// generateMySQLData generates sample data for MySQL
func generateMySQLData(config Config) error {
	log.Println("Generating MySQL data...")
	
	// Connect to MySQL
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s", config.User, config.Password, config.Host, config.Port, config.Database)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return fmt.Errorf("failed to connect to MySQL: %w", err)
	}
	defer db.Close()

	// Wait for MySQL to be ready
	for i := 0; i < 30; i++ {
		err = db.Ping()
		if err == nil {
			break
		}
		log.Printf("Waiting for MySQL to be ready... %v", err)
		time.Sleep(2 * time.Second)
	}
	if err != nil {
		return fmt.Errorf("MySQL is not ready after waiting: %w", err)
	}

	log.Println("Connected to MySQL successfully")

	// Generate random data for customers and orders
	for i := 0; i < 10; i++ {
		// Insert a new customer
		customerID, err := insertMySQLCustomer(db)
		if err != nil {
			log.Printf("Failed to insert MySQL customer: %v", err)
			continue
		}

		// Insert orders for the new customer
		numOrders := rand.Intn(3) + 1 // 1-3 orders per customer
		for j := 0; j < numOrders; j++ {
			err := insertMySQLOrder(db, customerID)
			if err != nil {
				log.Printf("Failed to insert MySQL order: %v", err)
			}
		}

		// Wait a bit between insertions to make it easier to see the changes
		time.Sleep(1 * time.Second)
	}

	return nil
}

// generatePostgreSQLData generates sample data for PostgreSQL
func generatePostgreSQLData(config Config) error {
	log.Println("Generating PostgreSQL data...")
	
	// Connect to PostgreSQL
	dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		config.Host, config.Port, config.User, config.Password, config.Database)
	db, err := sql.Open("postgres", dsn)
	if err != nil {
		return fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}
	defer db.Close()

	// Wait for PostgreSQL to be ready
	for i := 0; i < 30; i++ {
		err = db.Ping()
		if err == nil {
			break
		}
		log.Printf("Waiting for PostgreSQL to be ready... %v", err)
		time.Sleep(2 * time.Second)
	}
	if err != nil {
		return fmt.Errorf("PostgreSQL is not ready after waiting: %w", err)
	}

	log.Println("Connected to PostgreSQL successfully")

	// Generate random data for customers and orders
	for i := 0; i < 10; i++ {
		// Insert a new customer
		customerID, err := insertPostgreSQLCustomer(db)
		if err != nil {
			log.Printf("Failed to insert PostgreSQL customer: %v", err)
			continue
		}

		// Insert orders for the new customer
		numOrders := rand.Intn(3) + 1 // 1-3 orders per customer
		for j := 0; j < numOrders; j++ {
			err := insertPostgreSQLOrder(db, customerID)
			if err != nil {
				log.Printf("Failed to insert PostgreSQL order: %v", err)
			}
		}

		// Wait a bit between insertions to make it easier to see the changes
		time.Sleep(1 * time.Second)
	}

	return nil
}

// generateMongoDBData generates sample data for MongoDB
func generateMongoDBData(config Config) error {
	log.Println("Generating MongoDB data...")
	
	// Set up MongoDB client options
	clientOptions := options.Client().ApplyURI(
		fmt.Sprintf("mongodb://%s:%s@%s:%s",
			config.User, config.Password, config.Host, config.Port),
	)

	// Connect to MongoDB
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	
	client, err := mongo.Connect(ctx, clientOptions)
	if err != nil {
		return fmt.Errorf("failed to connect to MongoDB: %w", err)
	}
	defer client.Disconnect(ctx)

	// Check the connection
	err = client.Ping(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to ping MongoDB: %w", err)
	}

	log.Println("Connected to MongoDB successfully")

	// Get database and collections
	db := client.Database(config.Database)
	customersCollection := db.Collection("customers")
	ordersCollection := db.Collection("orders")

	// Generate random data for customers and orders
	for i := 0; i < 10; i++ {
		// Insert a new customer
		customerID := 1000 + int64(i)
		customer := createCustomer(customerID)
		
		_, err := customersCollection.InsertOne(ctx, customer)
		if err != nil {
			log.Printf("Failed to insert MongoDB customer: %v", err)
			continue
		}

		log.Printf("Inserted MongoDB customer: %s %s (ID: %d)", 
			customer["first_name"], customer["last_name"], customer["_id"])

		// Insert orders for the new customer
		numOrders := rand.Intn(3) + 1 // 1-3 orders per customer
		for j := 0; j < numOrders; j++ {
			orderID := 2000 + int64(i*3+j)
			order := createOrder(orderID, customerID)
			
			_, err := ordersCollection.InsertOne(ctx, order)
			if err != nil {
				log.Printf("Failed to insert MongoDB order: %v", err)
				continue
			}

			log.Printf("Inserted MongoDB order for customer ID %d: $%.2f, status: %s", 
				order["customer_id"], order["total"], order["status"])
		}

		// Wait a bit between insertions to make it easier to see the changes
		time.Sleep(1 * time.Second)
	}

	return nil
}

// generateOracleData generates sample data for Oracle
func generateOracleData(config Config) error {
	log.Println("Generating Oracle data...")
	
	// For Oracle, we'll use the Oracle Instant Client driver
	// This is a simplified implementation as the real driver would require Oracle client libraries
	log.Println("Note: Oracle support is simulated - in a real environment, you would need the Oracle client libraries")
	
	// In a real implementation, you would connect like this:
	// connStr := fmt.Sprintf("%s/%s@%s:%s/%s", 
	//     config.User, config.Password, config.Host, config.Port, config.Database)
	// db, err := sql.Open("oracle", connStr)
	
	// For demonstration purposes, we'll just log the actions without actually connecting
	log.Printf("Would connect to Oracle at %s:%s with user %s", config.Host, config.Port, config.User)
	
	// Simulate generating data
	for i := 0; i < 10; i++ {
		customerID := int64(100 + i)
		firstName := randomFirstName()
		lastName := randomLastName()
		email := fmt.Sprintf("%s.%s@example.com", firstName, lastName)
		
		log.Printf("Would insert Oracle customer: %s %s (ID: %d)", firstName, lastName, customerID)
		
		// Simulate inserting orders
		numOrders := rand.Intn(3) + 1
		for j := 0; j < numOrders; j++ {
			total := 10.0 + rand.Float64()*990.0
			status := randomOrderStatus()
			
			log.Printf("Would insert Oracle order for customer ID %d: $%.2f, status: %s", 
				customerID, total, status)
		}
		
		time.Sleep(1 * time.Second)
	}
	
	return nil
}

// generateCassandraData generates sample data for Cassandra
func generateCassandraData(config Config) error {
	log.Println("Generating Cassandra data...")
	
	// Connect to Cassandra
	port, _ := strconv.Atoi(config.Port)
	if port == 0 {
		port = 9042 // Default Cassandra port
	}
	
	cluster := gocql.NewCluster(config.Host)
	cluster.Port = port
	cluster.Authenticator = gocql.PasswordAuthenticator{
		Username: config.User,
		Password: config.Password,
	}
	cluster.Keyspace = config.Database
	cluster.Consistency = gocql.Quorum
	cluster.ConnectTimeout = 10 * time.Second

	session, err := cluster.CreateSession()
	if err != nil {
		return fmt.Errorf("failed to connect to Cassandra: %w", err)
	}
	defer session.Close()

	log.Println("Connected to Cassandra successfully")

	// Generate random data for customers and orders
	for i := 0; i < 10; i++ {
		// Insert a new customer
		customerID := 100 + i
		firstName := randomFirstName()
		lastName := randomLastName()
		email := fmt.Sprintf("%s.%s@example.com", firstName, lastName)

		// Insert the customer
		err := session.Query(
			"INSERT INTO customers (id, first_name, last_name, email, created_at) VALUES (?, ?, ?, ?, ?)",
			customerID, firstName, lastName, email, time.Now(),
		).Exec()
		
		if err != nil {
			log.Printf("Failed to insert Cassandra customer: %v", err)
			continue
		}

		log.Printf("Inserted Cassandra customer: %s %s (ID: %d)", firstName, lastName, customerID)

		// Insert orders for the new customer
		numOrders := rand.Intn(3) + 1 // 1-3 orders per customer
		for j := 0; j < numOrders; j++ {
			orderID := 200 + i*3 + j
			orderDate := time.Now()
			total := 10.0 + rand.Float64()*990.0  // Random total between $10 and $1000
			status := randomOrderStatus()

			// Insert the order
			err := session.Query(
				"INSERT INTO orders (id, customer_id, order_date, status, total) VALUES (?, ?, ?, ?, ?)",
				orderID, customerID, orderDate, status, total,
			).Exec()
			
			if err != nil {
				log.Printf("Failed to insert Cassandra order: %v", err)
				continue
			}

			log.Printf("Inserted Cassandra order for customer ID %d: $%.2f, status: %s", 
				customerID, total, status)
		}

		// Wait a bit between insertions to make it easier to see the changes
		time.Sleep(1 * time.Second)
	}

	return nil
}

// Helper functions for MySQL
func insertMySQLCustomer(db *sql.DB) (int64, error) {
	// Generate a random customer
	firstName := randomFirstName()
	lastName := randomLastName()
	email := fmt.Sprintf("%s.%s@example.com", firstName, lastName)

	// Insert the customer
	result, err := db.Exec(
		"INSERT INTO customers (first_name, last_name, email) VALUES (?, ?, ?)",
		firstName, lastName, email,
	)
	if err != nil {
		return 0, err
	}

	// Get the ID of the inserted customer
	id, err := result.LastInsertId()
	if err != nil {
		return 0, err
	}

	log.Printf("Inserted MySQL customer: %s %s (ID: %d)", firstName, lastName, id)
	return id, nil
}

func insertMySQLOrder(db *sql.DB, customerID int64) error {
	// Generate random order data
	orderDate := time.Now().AddDate(0, 0, -rand.Intn(30)) // Random date in the last 30 days
	total := 10.0 + rand.Float64()*990.0                  // Random total between $10 and $1000
	status := randomOrderStatus()

	// Insert the order
	_, err := db.Exec(
		"INSERT INTO orders (customer_id, order_date, total, status) VALUES (?, ?, ?, ?)",
		customerID, orderDate.Format("2006-01-02"), total, status,
	)
	if err != nil {
		return err
	}

	log.Printf("Inserted MySQL order for customer ID %d: $%.2f, status: %s", customerID, total, status)
	return nil
}

// Helper functions for PostgreSQL
func insertPostgreSQLCustomer(db *sql.DB) (int64, error) {
	// Generate a random customer
	firstName := randomFirstName()
	lastName := randomLastName()
	email := fmt.Sprintf("%s.%s@example.com", firstName, lastName)

	// Insert the customer
	var id int64
	err := db.QueryRow(
		"INSERT INTO customers (first_name, last_name, email) VALUES ($1, $2, $3) RETURNING id",
		firstName, lastName, email,
	).Scan(&id)
	
	if err != nil {
		return 0, err
	}

	log.Printf("Inserted PostgreSQL customer: %s %s (ID: %d)", firstName, lastName, id)
	return id, nil
}

func insertPostgreSQLOrder(db *sql.DB, customerID int64) error {
	// Generate random order data
	orderDate := time.Now().AddDate(0, 0, -rand.Intn(30)) // Random date in the last 30 days
	total := 10.0 + rand.Float64()*990.0                  // Random total between $10 and $1000
	status := randomOrderStatus()

	// Insert the order
	_, err := db.Exec(
		"INSERT INTO orders (customer_id, order_date, status, total) VALUES ($1, $2, $3, $4)",
		customerID, orderDate, status, total,
	)
	if err != nil {
		return err
	}

	log.Printf("Inserted PostgreSQL order for customer ID %d: $%.2f, status: %s", customerID, total, status)
	return nil
}

// Helper functions for creating MongoDB documents
func createCustomer(id int64) bson.M {
	firstName := randomFirstName()
	lastName := randomLastName()
	email := fmt.Sprintf("%s.%s@example.com", firstName, lastName)
	
	return bson.M{
		"_id":        id,
		"first_name": firstName,
		"last_name":  lastName,
		"email":      email,
		"created_at": time.Now(),
	}
}

func createOrder(id int64, customerID int64) bson.M {
	orderDate := time.Now().AddDate(0, 0, -rand.Intn(30)) // Random date in the last 30 days
	total := 10.0 + rand.Float64()*990.0                  // Random total between $10 and $1000
	status := randomOrderStatus()
	
	return bson.M{
		"_id":         id,
		"customer_id": customerID,
		"order_date":  orderDate,
		"status":      status,
		"total":       total,
	}
}

// Utility functions
func randomFirstName() string {
	firstNames := []string{
		"James", "Mary", "John", "Patricia", "Robert", "Jennifer", "Michael", "Linda",
		"William", "Elizabeth", "David", "Barbara", "Richard", "Susan", "Joseph", "Jessica",
		"Thomas", "Sarah", "Charles", "Karen", "Christopher", "Nancy", "Daniel", "Lisa",
		"Matthew", "Margaret", "Anthony", "Betty", "Mark", "Sandra", "Donald", "Ashley",
	}
	return firstNames[rand.Intn(len(firstNames))]
}

func randomLastName() string {
	lastNames := []string{
		"Smith", "Johnson", "Williams", "Jones", "Brown", "Davis", "Miller", "Wilson",
		"Moore", "Taylor", "Anderson", "Thomas", "Jackson", "White", "Harris", "Martin",
		"Thompson", "Garcia", "Martinez", "Robinson", "Clark", "Rodriguez", "Lewis", "Lee",
		"Walker", "Hall", "Allen", "Young", "Hernandez", "King", "Wright", "Lopez",
	}
	return lastNames[rand.Intn(len(lastNames))]
}

func randomOrderStatus() string {
	statuses := []string{"PENDING", "PROCESSING", "COMPLETED", "SHIPPED", "DELIVERED", "CANCELLED"}
	return statuses[rand.Intn(len(statuses))]
}

// getDBConfig gets the configuration for a specific database from environment variables
func getDBConfig(prefix string) Config {
	enabledStr := getEnv(fmt.Sprintf("ENABLE_%s", prefix), "false")
	enabled := strings.ToLower(enabledStr) == "true"
	
	return Config{
		Enabled:  enabled,
		Host:     getEnv(fmt.Sprintf("%s_HOST", prefix), "localhost"),
		Port:     getEnv(fmt.Sprintf("%s_PORT", prefix), ""),
		User:     getEnv(fmt.Sprintf("%s_USER", prefix), ""),
		Password: getEnv(fmt.Sprintf("%s_PASSWORD", prefix), ""),
		Database: getEnv(fmt.Sprintf("%s_DATABASE", prefix), ""),
	}
}

// getEnv gets an environment variable or returns the default value
func getEnv(key, defaultValue string) string {
	value := os.Getenv(key)
	if value == "" {
		return defaultValue
	}
	return value
}
